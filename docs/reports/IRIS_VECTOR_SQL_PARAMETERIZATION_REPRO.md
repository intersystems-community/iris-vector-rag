# IRIS Vector SQL Parameterization Repro — Minimal, Fully Reproducible Example

Status: OPEN bug report for InterSystems IRIS SQL cached query compilation with VECTOR operations

Owner: RAG Templates Team  
Related files:
- [`format_vector_search_sql()`](common/vector_sql_utils.py:173)
- [`format_vector_search_sql_with_params()`](common/vector_sql_utils.py:214)
- [`execute_vector_search_with_params()`](common/vector_sql_utils.py:293)
- Working direct example: [`scripts/test_direct_vector_search.py`](scripts/test_direct_vector_search.py:84)
- Ingestion (compliant): [`insert_vector()`](common/db_vector_utils.py:6), [`load_documents_to_iris()`](data/loader_fixed.py:97)

## Executive Summary

- Ingestion is fixed and compliant (all embeddings stored with 384 dims using vector utilities).
- Vector search fails when IRIS rewrites SQL literals (TOP N, TO_VECTOR type/dimension) into parameters during cached query compilation, producing invalid SQL.
- The ONLY reliable pattern we've found is binding a SINGLE vector string parameter (TO_VECTOR(?)) and leaving TOP as a literal in the SQL string. Attempts to include explicit type/dimension ('FLOAT', 384) get auto-parameterized by IRIS internally and fail.

This document provides a minimal, copy-paste reproducible script and expected outputs for Confluence review by InterSystems engineering and product.

## Environment

- OS: macOS Sequoia
- Python: 3.12 (venv)
- Project: RAG Templates
- IRIS: Running via docker-compose (version not printed here; see server logs for %sqlcq.USER.clsNNN)
- DB connector: InterSystems IRIS Python DB-API (via project connector in [`common/iris_dbapi_connector.py`](common/iris_dbapi_connector.py))

Start IRIS:
- make docker-up or docker-compose up -d (see .clinerules for project standards)

Ensure Python env active:
- poetry shell or source .venv/bin/activate

## Quick TL;DR Results

- Works:
  - VECTOR_DOT_PRODUCT with a single bound vector parameter:
    SELECT TOP 2 … VECTOR_DOT_PRODUCT(embedding, TO_VECTOR(?)) …
- Fails (IRIS auto-parameterizes literals into :%qpar and parser rejects):
  - SELECT TOP 2 … VECTOR_COSINE(embedding, TO_VECTOR(?, 'FLOAT', 384)) …
  - SELECT TOP 2 … VECTOR_COSINE(embedding, TO_VECTOR('[literal-vector]', 'FLOAT', 384)) …

## One-File Reproducer (copy-paste runnable)

This script:
1) Ensures a test table exists (USER.ReproVectors) with VECTOR(FLOAT, 384)
2) Inserts two rows using the approved vector utility [`insert_vector()`](common/db_vector_utils.py:6)
3) Demonstrates:
   - Working vector query (single bound parameter for vector)
   - Failing queries generated by the vector SQL utilities that IRIS rewrites into invalid cached queries

Run:
python3 docs/reports/IRIS_VECTOR_SQL_PARAMETERIZATION_REPRO.py

Create file docs/reports/IRIS_VECTOR_SQL_PARAMETERIZATION_REPRO.py with the following content:

```python
# docs/reports/IRIS_VECTOR_SQL_PARAMETERIZATION_REPRO.py
import sys, os
sys.path.insert(0, ".")
import random
from typing import List

from common.iris_dbapi_connector import get_iris_dbapi_connection
from common.utils import get_embedding_func
from common.db_vector_utils import insert_vector
from common.vector_sql_utils import (
    format_vector_search_sql,
    format_vector_search_sql_with_params,
    execute_vector_search_with_params,
)

TABLE = "USER.ReproVectors"  # isolated table for reproducibility
VECTOR_COL = "embedding"
DIM = 384

def ensure_table(cursor):
    cursor.execute("""
        SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES
        WHERE TABLE_SCHEMA = 'USER' AND TABLE_NAME = 'ReproVectors'
    """)
    exists = cursor.fetchone()[0] > 0
    if not exists:
        # Create minimal repro table
        cursor.execute(f"""
            CREATE TABLE {TABLE} (
              doc_id VARCHAR(64) PRIMARY KEY,
              title VARCHAR(200),
              {VECTOR_COL} VECTOR(FLOAT, {DIM})
            )
        """)
        cursor.connection.commit()

def upsert_two_rows(cursor, embed_func):
    texts = ["Repro doc A about medical trials", "Repro doc B about clinical research"]
    for i, text in enumerate(texts, start=1):
        emb: List[float] = embed_func(text)  # returns 384-dim
        ok = insert_vector(
            cursor=cursor,
            table_name=TABLE,
            vector_column_name=VECTOR_COL,
            vector_data=emb,
            target_dimension=DIM,
            key_columns={"doc_id": f"repro_{i}"},
            additional_data={"title": f"Repro Title {i}"}
        )
        if not ok:
            raise RuntimeError("insert_vector failed")
    cursor.connection.commit()

def print_rows(cursor, note):
    cursor.execute(f"SELECT doc_id, title FROM {TABLE}")
    rows = cursor.fetchall()
    print(f"{note} — rows in {TABLE}: {len(rows)}")
    for r in rows:
        print("  ", r)

def main():
    conn = get_iris_dbapi_connection()
    cur = conn.cursor()

    # 1) Ensure table + sample rows
    ensure_table(cur)
    embed = get_embedding_func()
    upsert_two_rows(cur, embed)
    print_rows(cur, "After upsert")

    # 2) Working pattern — single bound parameter (no explicit type/dimension binds)
    print("\n=== WORKING: Single bound vector parameter (VECTOR_DOT_PRODUCT with TO_VECTOR(?)) ===")
    # Build a query embedding and convert to comma-separated string (no brackets)
    qvec = embed("medical research document")
    qvec_str = ",".join(map(str, qvec))

    sql_working = f"""
        SELECT TOP 2 doc_id, title, VECTOR_DOT_PRODUCT({VECTOR_COL}, TO_VECTOR(?)) AS similarity
        FROM {TABLE}
        WHERE {VECTOR_COL} IS NOT NULL
        ORDER BY similarity DESC
    """
    try:
        cur.execute(sql_working, (qvec_str,))
        rows = cur.fetchall()
        print("WORKING results:", rows)
    except Exception as e:
        print("UNEXPECTED failure in working pattern:", e)

    # 3) Failing pattern A — parameterized vector + explicit type/dimension
    print("\n=== FAILING A: format_vector_search_sql_with_params (IRIS rewrites TOP/type/dim into :%qpar) ===")
    try:
        sql_params = format_vector_search_sql_with_params(
            table_name=TABLE,
            vector_column=VECTOR_COL,
            embedding_dim=DIM,
            top_k=2,
            id_column="doc_id",
            content_column="title"
        )
        # vector_string with brackets for TO_VECTOR text literal
        qvec_bracketed = "[" + ",".join(map(str, qvec)) + "]"
        # execute with parameter (as designed by utility)
        cur.execute(sql_params, [qvec_bracketed])
        rows = cur.fetchall()
        print("SHOULD HAVE FAILED but returned:", rows)
    except Exception as e:
        print("EXPECTED failure A:", e)

    # 4) Failing pattern B — fully literalized vector string embedded in SQL text
    print("\n=== FAILING B: format_vector_search_sql (no DBAPI params, still IRIS injects :%qpar in cached class) ===")
    try:
        qvec_bracketed = "[" + ",".join(map(str, qvec)) + "]"
        sql_literal = format_vector_search_sql(
            table_name=TABLE,
            vector_column=VECTOR_COL,
            vector_string=qvec_bracketed,
            embedding_dim=DIM,
            top_k=2,
            id_column="doc_id",
            content_column="title"
        )
        # Execute with NO DBAPI params
        cur.execute(sql_literal)
        rows = cur.fetchall()
        print("SHOULD HAVE FAILED but returned:", rows)
    except Exception as e:
        print("EXPECTED failure B:", e)

    cur.close()
    conn.close()

if __name__ == "__main__":
    main()
```

## Expected Output (Representative)

Working section prints results (values will vary):

```
=== WORKING: Single bound vector parameter (VECTOR_DOT_PRODUCT with TO_VECTOR(?)) ===
WORKING results: [('repro_1', 'Repro Title 1', 7.1234), ('repro_2', 'Repro Title 2', 6.9981)]
```

Failing sections reproduce IRIS cached query compile errors:

```
=== FAILING A: format_vector_search_sql_with_params (IRIS rewrites TOP/type/dim into :%qpar) ===
EXPECTED failure A: [SQLCODE: <-1>:<Invalid SQL statement>]
[Location: <Prepare>]
[%msg: < ) expected, : found ^SELECT TOP :%qpar(1) doc_id , title , VECTOR_COSINE ( embedding , TO_VECTOR ( :%qpar(2) , :%qpar>]

=== FAILING B: format_vector_search_sql (no DBAPI params, still IRIS injects :%qpar in cached class) ===
EXPECTED failure B: [SQLCODE: <-1>:<Invalid SQL statement>]
[Location: <Prepare>]
[%msg: < ) expected, : found ^SELECT TOP :%qpar(1) doc_id , title , VECTOR_COSINE ( embedding , TO_VECTOR ( :%qpar(2) , :%qpar>]
```

Note the :%qpar markers appear even when we provide no DBAPI parameters for case B — indicating server-side auto-parameterization during cached query compilation of literals (TOP/type/dim), which are then rejected by the parser.

## What Works Reliably (Current Workaround)

- Keep TOP N as a literal integer in the SQL sent to the server.
- Use TO_VECTOR(?) with a single bound parameter containing the comma-separated values (no brackets). This matches the working example in [`scripts/test_direct_vector_search.py`](scripts/test_direct_vector_search.py:84).

Example (shown above in the "WORKING" section):
- VECTOR_DOT_PRODUCT(embedding, TO_VECTOR(?))

## Why Utilities Fail Right Now

- [`format_vector_search_sql_with_params()`](common/vector_sql_utils.py:214) builds a query with TOP literal and TO_VECTOR(?, 'FLOAT', 384). On execution, IRIS converts TOP/type/dimension into :%qpar and the SQL parser rejects that.
- [`format_vector_search_sql()`](common/vector_sql_utils.py:173) builds a fully literalized query — no DBAPI params — yet cached compilation still inserts :%qpar for TOP/type/dimension and then fails.

## Requested Actions from InterSystems

1) Avoid auto-parameterizing TOP N and TO_VECTOR type/dimension literals during cached query compilation, or permit parameters in those positions.
2) Provide a server/session flag to disable this auto-parameterization for affected statements.
3) Document best practices for Python DB-API + IRIS VECTOR functions, including supported parameter patterns for TO_VECTOR (type/dimension).
4) Improve error messages to explicitly call out "parameter not allowed in TOP" or "parameter not allowed in TO_VECTOR dimension/type".

## Appendix A — Data Insertion Uses Vector Utilities

All inserts in this repro use [`insert_vector()`](common/db_vector_utils.py:6), which:
- Truncates/pads to target dimension
- Formats string for TO_VECTOR
- Uses INSERT first, UPDATE fallback on unique constraint

## Appendix B — Related Sources

- SQL builders:
  - [`format_vector_search_sql()`](common/vector_sql_utils.py:173)
  - [`format_vector_search_sql_with_params()`](common/vector_sql_utils.py:214)
  - [`execute_vector_search_with_params()`](common/vector_sql_utils.py:293)
- Working direct example:
  - [`scripts/test_direct_vector_search.py`](scripts/test_direct_vector_search.py:84)
- Ingestion (fixed):
  - [`load_documents_to_iris()`](data/loader_fixed.py:97)
  - [`insert_vector()`](common/db_vector_utils.py:6)