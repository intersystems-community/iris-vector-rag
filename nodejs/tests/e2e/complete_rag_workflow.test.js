// rag-templates/nodejs/tests/e2e/complete_rag_workflow.test.js
// End-to-end tests for complete RAG workflow with InterSystems IRIS

const { createVectorSearchPipeline } = require('../../src/index');
const { TestConfiguration } = require('../conftest');

describe('Complete RAG Workflow E2E', () => {
  let pipeline;
  let testConfig;

  beforeAll(async () => {
    testConfig = new TestConfiguration();
    
    // Skip E2E tests if not in real mode
    if (testConfig.getTestMode() !== 'real') {
      console.log('Skipping E2E tests - not in real mode');
      return;
    }

    // Create pipeline with real configuration
    pipeline = createVectorSearchPipeline({
      connection: {
        host: testConfig.getIrisHost(),
        port: testConfig.getIrisPort(),
        namespace: testConfig.getIrisNamespace(),
        username: testConfig.getIrisUsername(),
        password: testConfig.getIrisPassword()
      },
      embeddingModel: testConfig.getEmbeddingModel()
    });

    // Initialize the pipeline
    await pipeline.initialize();
  });

  afterAll(async () => {
    if (pipeline && testConfig.getTestMode() === 'real') {
      await pipeline.close();
    }
  });

  describe('InterSystems IRIS Documentation Processing', () => {
    const testDocuments = [
      {
        docId: 'iris_vector_search_001',
        title: 'IRIS Vector Search Overview',
        content: `
          InterSystems IRIS provides native vector search capabilities that enable similarity matching 
          and retrieval-augmented generation (RAG) workflows. The vector search functionality uses 
          cosine distance calculations to find semantically similar content in your data.
          
          Vector search in IRIS supports high-dimensional embeddings and uses the HNSW (Hierarchical 
          Navigable Small World) algorithm for efficient approximate nearest neighbor search. This 
          enables fast similarity matching even with large datasets.
        `,
        sourceFile: 'iris_vector_search_guide.pdf',
        pageNumber: 1,
        chunkIndex: 0
      },
      {
        docId: 'iris_ml_integration_001',
        title: 'Machine Learning Integration',
        content: `
          IRIS integrates seamlessly with machine learning workflows through its Python integration 
          and AutoML capabilities. The platform supports embedded Python for advanced analytics 
          and provides built-in functions for data science operations.
          
          The vector database capabilities in IRIS enable storing and querying high-dimensional 
          embeddings generated by machine learning models. This makes it ideal for AI applications 
          that require semantic search and similarity matching.
        `,
        sourceFile: 'iris_ml_integration.pdf',
        pageNumber: 2,
        chunkIndex: 0
      },
      {
        docId: 'iris_data_platform_001',
        title: 'IRIS Data Platform Features',
        content: `
          InterSystems IRIS is a complete data platform that combines database, integration, 
          and analytics capabilities. It provides both SQL and NoSQL data access patterns 
          and supports real-time data processing.
          
          The platform includes comprehensive security features, high availability options, 
          and scalability features that make it suitable for enterprise applications. 
          Vector search adds AI capabilities to traditional data management.
        `,
        sourceFile: 'iris_platform_overview.pdf',
        pageNumber: 1,
        chunkIndex: 1
      }
    ];

    beforeEach(async () => {
      if (testConfig.getTestMode() !== 'real') {
        return;
      }

      // Clean up any existing test documents
      for (const doc of testDocuments) {
        try {
          await pipeline.deleteDocument(doc.docId);
        } catch (error) {
          // Ignore errors if document doesn't exist
        }
      }
    });

    test('should index InterSystems documentation successfully', async () => {
      if (testConfig.getTestMode() !== 'real') {
        pending('Skipping real IRIS test');
        return;
      }

      // Index all test documents
      await pipeline.indexDocuments(testDocuments, { batchSize: 2 });

      // Verify documents were indexed
      for (const doc of testDocuments) {
        const exists = await pipeline.documentExists(doc.docId);
        expect(exists).toBe(true);
      }

      // Get collection stats
      const stats = await pipeline.getStats();
      expect(stats.totalDocuments).toBeGreaterThanOrEqual(testDocuments.length);
    });

    test('should perform semantic search on IRIS documentation', async () => {
      if (testConfig.getTestMode() !== 'real') {
        pending('Skipping real IRIS test');
        return;
      }

      // First ensure documents are indexed
      await pipeline.indexDocuments(testDocuments, { batchSize: 2 });

      // Test various search queries
      const searchQueries = [
        {
          query: 'vector search capabilities',
          expectedDocIds: ['iris_vector_search_001'],
          minResults: 1
        },
        {
          query: 'machine learning and AI integration',
          expectedDocIds: ['iris_ml_integration_001'],
          minResults: 1
        },
        {
          query: 'data platform features and database',
          expectedDocIds: ['iris_data_platform_001'],
          minResults: 1
        },
        {
          query: 'HNSW algorithm and similarity matching',
          expectedDocIds: ['iris_vector_search_001'],
          minResults: 1
        }
      ];

      for (const searchTest of searchQueries) {
        const results = await pipeline.search(searchTest.query, { 
          topK: 5,
          minSimilarity: 0.1 
        });

        expect(results.length).toBeGreaterThanOrEqual(searchTest.minResults);
        
        // Check if expected documents are in results
        const resultDocIds = results.map(r => r.docId);
        const hasExpectedDoc = searchTest.expectedDocIds.some(id => 
          resultDocIds.includes(id)
        );
        expect(hasExpectedDoc).toBe(true);

        // Verify result structure
        results.forEach(result => {
          expect(result).toHaveProperty('docId');
          expect(result).toHaveProperty('textContent');
          expect(result).toHaveProperty('sourceFile');
          expect(result).toHaveProperty('pageNumber');
          expect(result).toHaveProperty('chunkIndex');
          expect(result).toHaveProperty('score');
          expect(result.score).toBeGreaterThan(0);
          expect(result.score).toBeLessThanOrEqual(1);
        });
      }
    });

    test('should handle document updates and deletions', async () => {
      if (testConfig.getTestMode() !== 'real') {
        pending('Skipping real IRIS test');
        return;
      }

      const testDoc = testDocuments[0];
      
      // Index initial document
      await pipeline.indexDocument(
        testDoc.docId,
        testDoc.title,
        testDoc.content,
        testDoc.sourceFile,
        testDoc.pageNumber,
        testDoc.chunkIndex
      );

      // Verify document exists
      let exists = await pipeline.documentExists(testDoc.docId);
      expect(exists).toBe(true);

      // Update document content
      const updatedContent = `
        Updated content: InterSystems IRIS now includes enhanced vector search capabilities 
        with improved performance and new similarity algorithms. The latest version supports 
        advanced embedding models and provides better integration with modern AI workflows.
      `;

      await pipeline.updateDocument(testDoc.docId, updatedContent);

      // Search for updated content
      const searchResults = await pipeline.search('enhanced vector search capabilities', {
        topK: 3
      });

      const updatedDoc = searchResults.find(r => r.docId === testDoc.docId);
      expect(updatedDoc).toBeDefined();
      expect(updatedDoc.textContent).toContain('enhanced vector search capabilities');

      // Delete document
      await pipeline.deleteDocument(testDoc.docId);

      // Verify document no longer exists
      exists = await pipeline.documentExists(testDoc.docId);
      expect(exists).toBe(false);
    });

    test('should handle large document processing with chunking', async () => {
      if (testConfig.getTestMode() !== 'real') {
        pending('Skipping real IRIS test');
        return;
      }

      const largeDocument = `
        InterSystems IRIS Vector Search Comprehensive Guide
        
        Chapter 1: Introduction to Vector Search
        Vector search is a powerful technique for finding semantically similar content in large datasets.
        Unlike traditional keyword-based search, vector search uses mathematical representations of 
        content meaning to identify relevant information.
        
        Chapter 2: IRIS Vector Implementation
        InterSystems IRIS implements vector search using high-dimensional embeddings stored as 
        native data types. The platform supports various distance metrics including cosine distance,
        Euclidean distance, and dot product similarity.
        
        Chapter 3: HNSW Algorithm
        The Hierarchical Navigable Small World (HNSW) algorithm provides efficient approximate 
        nearest neighbor search. IRIS uses this algorithm to enable fast similarity matching 
        even with millions of vectors.
        
        Chapter 4: Integration with AI Workflows
        IRIS vector search integrates seamlessly with machine learning pipelines and AI applications.
        The platform supports real-time embedding generation and provides APIs for various 
        programming languages.
        
        Chapter 5: Performance Optimization
        Vector search performance in IRIS can be optimized through proper indexing strategies,
        appropriate vector dimensions, and efficient query patterns. The platform provides 
        monitoring tools to track search performance.
        
        Chapter 6: Security and Access Control
        IRIS provides comprehensive security features for vector search including role-based 
        access control, data encryption, and audit logging. These features ensure that 
        sensitive vector data remains protected.
      `;

      const chunkIds = await pipeline.processAndIndexDocument(
        'large_iris_guide',
        'Comprehensive IRIS Vector Search Guide',
        largeDocument,
        'iris_comprehensive_guide.pdf',
        1,
        {
          chunking: {
            chunkSize: 300,
            overlap: 50,
            splitOnSentences: true
          }
        }
      );

      expect(Array.isArray(chunkIds)).toBe(true);
      expect(chunkIds.length).toBeGreaterThan(3);

      // Test search across chunks
      const searchResults = await pipeline.search('HNSW algorithm performance', {
        topK: 5
      });

      expect(searchResults.length).toBeGreaterThan(0);
      
      // Should find relevant chunks
      const relevantChunk = searchResults.find(r => 
        r.textContent.includes('HNSW') || r.textContent.includes('algorithm')
      );
      expect(relevantChunk).toBeDefined();

      // Clean up
      for (const chunkId of chunkIds) {
        await pipeline.deleteDocument(chunkId);
      }
    });

    test('should handle concurrent operations safely', async () => {
      if (testConfig.getTestMode() !== 'real') {
        pending('Skipping real IRIS test');
        return;
      }

      // Prepare concurrent operations
      const concurrentDocs = testDocuments.map((doc, index) => ({
        ...doc,
        docId: `concurrent_${doc.docId}_${index}`
      }));

      const indexOperations = concurrentDocs.map(doc =>
        pipeline.indexDocument(
          doc.docId,
          doc.title,
          doc.content,
          doc.sourceFile,
          doc.pageNumber,
          doc.chunkIndex
        )
      );

      const searchOperations = [
        pipeline.search('vector search'),
        pipeline.search('machine learning'),
        pipeline.search('data platform')
      ];

      // Execute operations concurrently
      const [indexResults, searchResults] = await Promise.all([
        Promise.all(indexOperations),
        Promise.all(searchOperations)
      ]);

      // Verify all operations completed successfully
      expect(indexResults).toHaveLength(concurrentDocs.length);
      expect(searchResults).toHaveLength(3);

      searchResults.forEach(results => {
        expect(Array.isArray(results)).toBe(true);
      });

      // Clean up concurrent documents
      const deleteOperations = concurrentDocs.map(doc =>
        pipeline.deleteDocument(doc.docId)
      );
      await Promise.all(deleteOperations);
    });
  });

  describe('Error Handling and Edge Cases', () => {
    test('should handle connection failures gracefully', async () => {
      if (testConfig.getTestMode() !== 'real') {
        pending('Skipping real IRIS test');
        return;
      }

      // Create pipeline with invalid connection
      const invalidPipeline = createVectorSearchPipeline({
        connection: {
          host: 'invalid-host',
          port: 9999,
          namespace: 'INVALID',
          username: 'invalid',
          password: 'invalid'
        }
      });

      await expect(invalidPipeline.search('test query')).rejects.toThrow();
    });

    test('should validate input parameters', async () => {
      if (testConfig.getTestMode() !== 'real') {
        pending('Skipping real IRIS test');
        return;
      }

      // Test invalid search queries
      await expect(pipeline.search('')).rejects.toThrow();
      await expect(pipeline.search(null)).rejects.toThrow();
      await expect(pipeline.search(undefined)).rejects.toThrow();

      // Test invalid document parameters
      await expect(pipeline.indexDocument()).rejects.toThrow();
      await expect(pipeline.indexDocument('', 'title', 'content')).rejects.toThrow();
      await expect(pipeline.indexDocument('id', '', '')).rejects.toThrow();
    });

    test('should handle empty search results', async () => {
      if (testConfig.getTestMode() !== 'real') {
        pending('Skipping real IRIS test');
        return;
      }

      const results = await pipeline.search('xyzabc123nonexistentquery456', {
        topK: 10
      });

      expect(Array.isArray(results)).toBe(true);
      expect(results).toHaveLength(0);
    });
  });

  describe('Performance and Scalability', () => {
    test('should handle reasonable load efficiently', async () => {
      if (testConfig.getTestMode() !== 'real') {
        pending('Skipping real IRIS test');
        return;
      }

      const startTime = Date.now();

      // Perform multiple search operations
      const searchPromises = Array(10).fill(0).map((_, i) =>
        pipeline.search(`test query ${i}`, { topK: 5 })
      );

      const results = await Promise.all(searchPromises);
      const endTime = Date.now();

      // Should complete within reasonable time
      expect(endTime - startTime).toBeLessThan(30000); // 30 seconds

      // All searches should return arrays
      results.forEach(result => {
        expect(Array.isArray(result)).toBe(true);
      });
    });

    test('should provide accurate statistics', async () => {
      if (testConfig.getTestMode() !== 'real') {
        pending('Skipping real IRIS test');
        return;
      }

      const stats = await pipeline.getStats();

      expect(stats).toHaveProperty('totalDocuments');
      expect(stats).toHaveProperty('totalFiles');
      expect(typeof stats.totalDocuments).toBe('number');
      expect(typeof stats.totalFiles).toBe('number');
      expect(stats.totalDocuments).toBeGreaterThanOrEqual(0);
      expect(stats.totalFiles).toBeGreaterThanOrEqual(0);
    });
  });
});