#!/usr/bin/env python3
"""
Drop and repopulate GraphRAG entities with proper vector storage
"""

import sys
sys.path.append('.')

from common.iris_connector import get_iris_connection
from common.embedding_utils import get_embedding_model
import time

def repopulate_graphrag():
    """Drop and recreate GraphRAG tables with proper vector support"""
    print("üîÑ Repopulating GraphRAG with Proper Vector Storage")
    print("=" * 60)
    
    iris = get_iris_connection()
    cursor = iris.cursor()
    
    try:
        # Step 1: Drop existing tables
        print("\n1Ô∏è‚É£ Dropping existing GraphRAG tables...")
        
        # Drop relationships first (foreign key constraint)
        try:
            cursor.execute("DROP TABLE RAG.Relationships")
            print("   ‚úÖ Dropped Relationships table")
        except Exception as e:
            print(f"   ‚ÑπÔ∏è  Could not drop Relationships: {e}")
        
        # Drop entities
        try:
            cursor.execute("DROP TABLE RAG.Entities")
            print("   ‚úÖ Dropped Entities table")
        except Exception as e:
            print(f"   ‚ÑπÔ∏è  Could not drop Entities: {e}")
        
        iris.commit()
        
        # Step 2: Recreate tables with VECTOR type
        print("\n2Ô∏è‚É£ Creating new tables with VECTOR type...")
        
        # Create Entities table with VECTOR type
        cursor.execute("""
            CREATE TABLE RAG.Entities (
                entity_id VARCHAR(255) PRIMARY KEY,
                entity_name VARCHAR(500) NOT NULL,
                entity_type VARCHAR(100),
                source_doc_id VARCHAR(255),
                embedding VECTOR(DOUBLE, 384),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        print("   ‚úÖ Created Entities table with VECTOR type")
        
        # Create Relationships table
        cursor.execute("""
            CREATE TABLE RAG.Relationships (
                relationship_id VARCHAR(255) PRIMARY KEY,
                source_entity_id VARCHAR(255),
                target_entity_id VARCHAR(255),
                relationship_type VARCHAR(100),
                source_doc_id VARCHAR(255),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (source_entity_id) REFERENCES RAG.Entities(entity_id),
                FOREIGN KEY (target_entity_id) REFERENCES RAG.Entities(entity_id)
            )
        """)
        print("   ‚úÖ Created Relationships table")
        
        iris.commit()
        
        # Step 3: Create indexes
        print("\n3Ô∏è‚É£ Creating indexes...")
        
        # Create HNSW index on entity embeddings
        try:
            cursor.execute("""
                CREATE VECTOR INDEX idx_entity_embedding_hnsw 
                ON RAG.Entities (embedding) 
                USING HNSW 
                WITH ('dim' = 384, 'M' = 16, 'efConstruction' = 200)
            """)
            print("   ‚úÖ Created HNSW index on embeddings")
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Could not create HNSW index: {e}")
        
        # Other indexes
        indexes = [
            ("idx_entity_name", "RAG.Entities (entity_name)"),
            ("idx_entity_type", "RAG.Entities (entity_type)"),
            ("idx_entity_doc", "RAG.Entities (source_doc_id)"),
            ("idx_rel_source", "RAG.Relationships (source_entity_id)"),
            ("idx_rel_target", "RAG.Relationships (target_entity_id)"),
            ("idx_rel_type", "RAG.Relationships (relationship_type)")
        ]
        
        for idx_name, idx_def in indexes:
            try:
                cursor.execute(f"CREATE INDEX {idx_name} ON {idx_def}")
                print(f"   ‚úÖ Created {idx_name}")
            except Exception as e:
                if "already exists" in str(e):
                    print(f"   ‚ÑπÔ∏è  {idx_name} already exists")
                else:
                    print(f"   ‚ö†Ô∏è  Could not create {idx_name}: {e}")
        
        iris.commit()
        
        # Step 4: Test vector operations
        print("\n4Ô∏è‚É£ Testing vector operations...")
        
        # Get embedding model
        embedding_model = get_embedding_model('sentence-transformers/all-MiniLM-L6-v2')
        
        # Create test entities
        test_entities = [
            ("test-1", "diabetes", "DISEASE"),
            ("test-2", "insulin", "DRUG"),
            ("test-3", "pancreas", "ORGAN")
        ]
        
        for entity_id, entity_name, entity_type in test_entities:
            embedding = embedding_model.encode([entity_name])[0]
            cursor.execute("""
                INSERT INTO RAG.Entities (entity_id, entity_name, entity_type, embedding)
                VALUES (?, ?, ?, TO_VECTOR(?))
            """, [entity_id, entity_name, entity_type, str(embedding.tolist())])
        
        iris.commit()
        print("   ‚úÖ Inserted test entities")
        
        # Test vector search
        query_embedding = embedding_model.encode(["diabetes treatment"])[0]
        cursor.execute("""
            SELECT entity_name, entity_type,
                   VECTOR_COSINE(embedding, TO_VECTOR(?)) as similarity
            FROM RAG.Entities
            ORDER BY similarity DESC
        """, [str(query_embedding.tolist())])
        
        print("   Vector search results:")
        for name, type_, sim in cursor.fetchall():
            print(f"     - {name} ({type_}): {sim:.4f}")
        
        print("   ‚úÖ Vector operations working correctly!")
        
        # Clean up test data
        cursor.execute("DELETE FROM RAG.Entities WHERE entity_id LIKE 'test-%'")
        iris.commit()
        
        print("\n‚úÖ GraphRAG tables recreated with proper vector support!")
        print("\nNext steps:")
        print("1. Run general_graphrag_ingestion.py to repopulate entities")
        print("2. The new VECTOR type should handle large-scale operations better")
        
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
    finally:
        cursor.close()
        iris.close()

if __name__ == "__main__":
    repopulate_graphrag()