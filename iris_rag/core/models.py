import uuid
from dataclasses import dataclass, field
from typing import Dict, Any


def default_id_factory():
    """Generates a default UUID for document ID."""
    return str(uuid.uuid4())


@dataclass(frozen=True)  # frozen=True makes instances hashable if all fields are hashable
class Document:
    """
    Represents a single document or a piece of text content.

    Attributes:
        page_content: The main textual content of the document.
        metadata: A dictionary of additional information about the document
                  (e.g., source, page number, author). Defaults to an empty dict.
        id: A unique identifier for the document. Defaults to a generated UUID string.
            Can be provided if a specific ID is required.
    """

    page_content: str
    # metadata will be stored as a tuple of sorted (key, value) tuples to ensure hashability
    # The __init__ generated by dataclass will still accept a dict for metadata.
    # We will handle the conversion in __post_init__, but this requires frozen=False temporarily,
    # or a custom __init__.
    # For frozen=True, we must ensure the input type is already hashable or convert it
    # before the object is frozen.
    # A common pattern is to use a property or a factory, or to accept an immutable type.

    # Let's adjust so metadata is stored as a tuple of (key, value) items, sorted for consistency.
    # We'll need a custom __init__ if we want to accept a dict and convert it while frozen=True.
    # Or, we can require the user to pass an immutable representation.

    # Simpler: For frozen dataclasses, if a field is mutable (like dict) and part of hashing/equality,
    # it causes issues. If metadata is truly part of the Document's identity for hashing,
    # it should be immutable.
    # Let's make it so that the Document is hashable by its ID primarily, and eq checks all.
    # This means we might need to implement __hash__ manually if metadata dict is kept.
    # Or, if frozen=True, all fields contributing to eq must be hashable.

    # The simplest fix for the test, given frozen=True, is to ensure metadata is stored as an immutable, hashable type.
    # We can convert it in __post_init__ by temporarily unfreezing, or by using a more complex setup.
    # OR, we can define __hash__ manually.
    # Let's try defining __hash__ manually based on all fields, converting metadata on the fly.
    metadata: Dict[str, Any] = field(default_factory=dict)
    id: str = field(default_factory=default_id_factory)

    # __eq__ is auto-generated and compares all fields.
    # For __hash__ to work with a dict field when frozen=True, it's tricky.
    # Python's default for frozen=True is: if __eq__ is True (default) and __hash__ is None (default),
    # it tries to generate __hash__. If it finds an unhashable field like dict, it fails.

    # Let's remove frozen=True for a moment to implement custom __hash__ and __eq__
    # to handle the dict correctly. Or, better, keep frozen=True and make metadata
    # a field that doesn't participate in hashing if it's a dict, or convert it.

    # The test expects doc1 == doc2, where metadata is part of comparison.
    # And it expects doc1 to be hashable.
    # The issue is that dict itself is unhashable.

    # If we keep frozen=True, we must ensure all fields are hashable.
    # We can change metadata to store an immutable representation.
    # For example, a frozenset of items.

    # Let's try this: metadata will be converted to a frozenset of its items.
    # This requires a custom __init__ or a factory, as __post_init__ can't modify fields in a frozen dataclass.

    # Alternative: Keep frozen=True, and for metadata, use a type that is hashable.
    # The test passes `metadata={"a": 1}`.
    # The simplest way to pass the test is to ensure that the `metadata` field,
    # as part of the dataclass, is treated as hashable.
    # This means the `dict` must be converted to a hashable form for the hash calculation.
    # Dataclasses with `frozen=True` will generate `__hash__` if all fields are hashable.
    # Since `dict` is not, it fails.
    # The fix is to ensure `metadata` is stored as a hashable type, e.g., `frozenset(self.metadata.items())`
    # or a tuple of sorted items.

    # Let's modify the field itself to be a tuple of tuples, and handle dict input in __init__
    # This is not possible with frozen=True and default __init__.

    # Easiest for now: make Document not frozen, and implement __eq__ and __hash__.
    # Or, for the test to pass with frozen=True, the test itself needs to ensure it passes
    # hashable metadata, or the Document needs to transform it.

    # The problem is `metadata: Dict[str, Any]`. If this is part of the hash, it fails.
    # If we make it `eq=False, hash=False` for this field, then it would work but not meet test criteria for equality.

    # Let's make metadata a field that is converted to a hashable type.
    # We can use a property, but that's for access.
    # The actual stored type needs to be hashable.

    # Simplest change to pass the test:
    # The test uses `metadata={"a": 1}`.
    # The dataclass tries to hash this dict.
    # If we change the Document to not be frozen, then __hash__ is None by default.
    # But the test `d = {doc1: "test"}` requires hashability.

    # The core issue: a frozen dataclass with a dict field used in eq comparison
    # will not auto-generate a hash function.
    # We need to provide one, or change the field type.
    # Let's provide a custom __hash__.

    def __hash__(self):
        # Convert dict to a hashable form (tuple of sorted items) for hashing
        meta_tuple = tuple(sorted(self.metadata.items()))
        return hash((self.page_content, meta_tuple, self.id))

    # Note: If __hash__ is defined, __eq__ should also be defined if not using dataclass's default.
    # Since frozen=True implies eq=True by default, the auto-generated __eq__ should be fine
    # as it compares dictionaries correctly. The issue was only hashing.

    def __post_init__(self):
        """Post-initialization checks."""
        if not isinstance(self.page_content, str):
            raise TypeError("page_content must be a string.")
        if not isinstance(self.metadata, dict):
            raise TypeError("metadata must be a dictionary.")
        if not isinstance(self.id, str):
            raise TypeError("id must be a string.")
        if not self.id:
            raise ValueError("id cannot be empty.")


# Example of how other models might be added later:
# @dataclass(frozen=True)
# class Chunk(Document):
#     """Represents a chunk of a larger document."""
#     parent_document_id: str
#     chunk_index: int
#     # Could have its own metadata or inherit/extend parent's

# @dataclass(frozen=True)
# class RetrievedDocument:
#     """Represents a document retrieved by the RAG pipeline, possibly with a score."""
#     document: Document
#     score: float = field(default=0.0)
#     # Any other retrieval-specific info
