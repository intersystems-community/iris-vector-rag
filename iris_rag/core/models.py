import uuid
from dataclasses import dataclass, field
from typing import Dict, Any


def default_id_factory():
    """Generates a default UUID for document ID."""
    return str(uuid.uuid4())


@dataclass(
    frozen=True
)  # frozen=True makes instances hashable if all fields are hashable
class Document:
    """
    Represents a single document or a piece of text content.

    Attributes:
        page_content: The main textual content of the document.
        metadata: A dictionary of additional information about the document
                  (e.g., source, page number, author). Defaults to an empty dict.
        id: A unique identifier for the document. Defaults to a generated UUID string.
            Can be provided if a specific ID is required.
    """

    page_content: str
    # metadata will be stored as a tuple of sorted (key, value) tuples to ensure hashability
    # The __init__ generated by dataclass will still accept a dict for metadata.
    # We will handle the conversion in __post_init__, but this requires frozen=False temporarily,
    # or a custom __init__.
    # For frozen=True, we must ensure the input type is already hashable or convert it
    # before the object is frozen.
    # A common pattern is to use a property or a factory, or to accept an immutable type.

    # Let's adjust so metadata is stored as a tuple of (key, value) items, sorted for consistency.
    # We'll need a custom __init__ if we want to accept a dict and convert it while frozen=True.
    # Or, we can require the user to pass an immutable representation.

    # Simpler: For frozen dataclasses, if a field is mutable (like dict) and part of hashing/equality,
    # it causes issues. If metadata is truly part of the Document's identity for hashing,
    # it should be immutable.
    # Let's make it so that the Document is hashable by its ID primarily, and eq checks all.
    # This means we might need to implement __hash__ manually if metadata dict is kept.
    # Or, if frozen=True, all fields contributing to eq must be hashable.

    # The simplest fix for the test, given frozen=True, is to ensure metadata is stored as an immutable, hashable type.
    # We can convert it in __post_init__ by temporarily unfreezing, or by using a more complex setup.
    # OR, we can define __hash__ manually.
    # Let's try defining __hash__ manually based on all fields, converting metadata on the fly.
    metadata: Dict[str, Any] = field(default_factory=dict)
    id: str = field(default_factory=default_id_factory)

    # __eq__ is auto-generated and compares all fields.
    # For __hash__ to work with a dict field when frozen=True, it's tricky.
    # Python's default for frozen=True is: if __eq__ is True (default) and __hash__ is None (default),
    # it tries to generate __hash__. If it finds an unhashable field like dict, it fails.

    # Let's remove frozen=True for a moment to implement custom __hash__ and __eq__
    # to handle the dict correctly. Or, better, keep frozen=True and make metadata
    # a field that doesn't participate in hashing if it's a dict, or convert it.

    # The test expects doc1 == doc2, where metadata is part of comparison.
    # And it expects doc1 to be hashable.
    # The issue is that dict itself is unhashable.

    # If we keep frozen=True, we must ensure all fields are hashable.
    # We can change metadata to store an immutable representation.
    # For example, a frozenset of items.

    # Let's try this: metadata will be converted to a frozenset of its items.
    # This requires a custom __init__ or a factory, as __post_init__ can't modify fields in a frozen dataclass.

    # Alternative: Keep frozen=True, and for metadata, use a type that is hashable.
    # The test passes `metadata={"a": 1}`.
    # The simplest way to pass the test is to ensure that the `metadata` field,
    # as part of the dataclass, is treated as hashable.
    # This means the `dict` must be converted to a hashable form for the hash calculation.
    # Dataclasses with `frozen=True` will generate `__hash__` if all fields are hashable.
    # Since `dict` is not, it fails.
    # The fix is to ensure `metadata` is stored as a hashable type, e.g., `frozenset(self.metadata.items())`
    # or a tuple of sorted items.

    # Let's modify the field itself to be a tuple of tuples, and handle dict input in __init__
    # This is not possible with frozen=True and default __init__.

    # Easiest for now: make Document not frozen, and implement __eq__ and __hash__.
    # Or, for the test to pass with frozen=True, the test itself needs to ensure it passes
    # hashable metadata, or the Document needs to transform it.

    # The problem is `metadata: Dict[str, Any]`. If this is part of the hash, it fails.
    # If we make it `eq=False, hash=False` for this field, then it would work but not meet test criteria for equality.

    # Let's make metadata a field that is converted to a hashable type.
    # We can use a property, but that's for access.
    # The actual stored type needs to be hashable.

    # Simplest change to pass the test:
    # The test uses `metadata={"a": 1}`.
    # The dataclass tries to hash this dict.
    # If we change the Document to not be frozen, then __hash__ is None by default.
    # But the test `d = {doc1: "test"}` requires hashability.

    # The core issue: a frozen dataclass with a dict field used in eq comparison
    # will not auto-generate a hash function.
    # We need to provide one, or change the field type.
    # Let's provide a custom __hash__.

    def __hash__(self):
        # Convert dict to a hashable form (tuple of sorted items) for hashing
        meta_tuple = tuple(sorted(self.metadata.items()))
        return hash((self.page_content, meta_tuple, self.id))

    # Note: If __hash__ is defined, __eq__ should also be defined if not using dataclass's default.
    # Since frozen=True implies eq=True by default, the auto-generated __eq__ should be fine
    # as it compares dictionaries correctly. The issue was only hashing.

    def __post_init__(self):
        """Post-initialization checks."""
        if not isinstance(self.page_content, str):
            raise TypeError("page_content must be a string.")
        if not isinstance(self.metadata, dict):
            raise TypeError("metadata must be a dictionary.")
        if not isinstance(self.id, str):
            raise TypeError("id must be a string.")
        if not self.id:
            raise ValueError("id cannot be empty.")


@dataclass(frozen=True)
class Entity:
    """
    Represents an extracted entity from text processing.

    Attributes:
        text: The actual text span of the entity as it appears in the source
        entity_type: The type/category of the entity (e.g., PERSON, DISEASE, DRUG, etc.)
        confidence: Confidence score of the extraction (0.0 to 1.0)
        start_offset: Character offset where entity starts in source text
        end_offset: Character offset where entity ends in source text
        source_document_id: ID of the document this entity was extracted from
        metadata: Additional information about the entity (embeddings, context, etc.)
        id: Unique identifier for the entity
    """

    text: str
    entity_type: str
    confidence: float
    start_offset: int
    end_offset: int
    source_document_id: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    id: str = field(default_factory=default_id_factory)

    def __hash__(self):
        """Convert dict metadata to hashable form for hashing."""
        meta_tuple = tuple(sorted(self.metadata.items()))
        return hash(
            (
                self.text,
                self.entity_type,
                self.confidence,
                self.start_offset,
                self.end_offset,
                self.source_document_id,
                meta_tuple,
                self.id,
            )
        )

    def __post_init__(self):
        """Post-initialization validation."""
        if not isinstance(self.text, str) or not self.text.strip():
            raise ValueError("Entity text must be a non-empty string.")
        if not isinstance(self.entity_type, str) or not self.entity_type.strip():
            raise ValueError("Entity type must be a non-empty string.")
        if not (0.0 <= self.confidence <= 1.0):
            raise ValueError("Confidence must be between 0.0 and 1.0.")
        if not isinstance(self.start_offset, int) or self.start_offset < 0:
            raise ValueError("Start offset must be a non-negative integer.")
        if not isinstance(self.end_offset, int) or self.end_offset < self.start_offset:
            raise ValueError("End offset must be >= start offset.")
        if (
            not isinstance(self.source_document_id, str)
            or not self.source_document_id.strip()
        ):
            raise ValueError("Source document ID must be a non-empty string.")
        if not isinstance(self.metadata, dict):
            raise TypeError("Metadata must be a dictionary.")
        if not isinstance(self.id, str) or not self.id.strip():
            raise ValueError("Entity ID must be a non-empty string.")


@dataclass(frozen=True)
class Relationship:
    """
    Represents a relationship between two entities.

    Attributes:
        source_entity_id: ID of the source entity in the relationship
        target_entity_id: ID of the target entity in the relationship
        relationship_type: Type of relationship (e.g., "causes", "treats", "interacts_with")
        confidence: Confidence score of the relationship extraction (0.0 to 1.0)
        source_document_id: ID of the document where this relationship was found
        metadata: Additional information about the relationship (context, evidence, etc.)
        id: Unique identifier for the relationship
    """

    source_entity_id: str
    target_entity_id: str
    relationship_type: str
    confidence: float
    source_document_id: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    id: str = field(default_factory=default_id_factory)

    def __hash__(self):
        """Convert dict metadata to hashable form for hashing."""
        meta_tuple = tuple(sorted(self.metadata.items()))
        return hash(
            (
                self.source_entity_id,
                self.target_entity_id,
                self.relationship_type,
                self.confidence,
                self.source_document_id,
                meta_tuple,
                self.id,
            )
        )

    def __post_init__(self):
        """Post-initialization validation."""
        if (
            not isinstance(self.source_entity_id, str)
            or not self.source_entity_id.strip()
        ):
            raise ValueError("Source entity ID must be a non-empty string.")
        if (
            not isinstance(self.target_entity_id, str)
            or not self.target_entity_id.strip()
        ):
            raise ValueError("Target entity ID must be a non-empty string.")
        if self.source_entity_id == self.target_entity_id:
            raise ValueError("Source and target entity IDs cannot be the same.")
        if (
            not isinstance(self.relationship_type, str)
            or not self.relationship_type.strip()
        ):
            raise ValueError("Relationship type must be a non-empty string.")
        if not (0.0 <= self.confidence <= 1.0):
            raise ValueError("Confidence must be between 0.0 and 1.0.")
        if (
            not isinstance(self.source_document_id, str)
            or not self.source_document_id.strip()
        ):
            raise ValueError("Source document ID must be a non-empty string.")
        if not isinstance(self.metadata, dict):
            raise TypeError("Metadata must be a dictionary.")
        if not isinstance(self.id, str) or not self.id.strip():
            raise ValueError("Relationship ID must be a non-empty string.")


# Common entity types for biomedical domain (based on SOTA research)
class EntityTypes:
    """Standard entity types for biomedical and general domain extraction."""

    # Biomedical entities (from OpenMed and medical NER research)
    PERSON = "PERSON"
    DISEASE = "DISEASE"
    DRUG = "DRUG"
    TREATMENT = "TREATMENT"
    SYMPTOM = "SYMPTOM"
    GENE = "GENE"
    PROTEIN = "PROTEIN"
    ANATOMY = "ANATOMY"
    PROCEDURE = "PROCEDURE"
    DEVICE = "DEVICE"

    # General entities
    ORGANIZATION = "ORGANIZATION"
    LOCATION = "LOCATION"
    DATE = "DATE"
    MONEY = "MONEY"
    PERCENT = "PERCENT"
    PRODUCT = "PRODUCT"
    EVENT = "EVENT"

    @classmethod
    def all_types(cls) -> set:
        """Return all available entity types."""
        return {
            cls.PERSON,
            cls.DISEASE,
            cls.DRUG,
            cls.TREATMENT,
            cls.SYMPTOM,
            cls.GENE,
            cls.PROTEIN,
            cls.ANATOMY,
            cls.PROCEDURE,
            cls.DEVICE,
            cls.ORGANIZATION,
            cls.LOCATION,
            cls.DATE,
            cls.MONEY,
            cls.PERCENT,
            cls.PRODUCT,
            cls.EVENT,
        }

    @classmethod
    def biomedical_types(cls) -> set:
        """Return biomedical-specific entity types."""
        return {
            cls.PERSON,
            cls.DISEASE,
            cls.DRUG,
            cls.TREATMENT,
            cls.SYMPTOM,
            cls.GENE,
            cls.PROTEIN,
            cls.ANATOMY,
            cls.PROCEDURE,
            cls.DEVICE,
        }


# Common relationship types
class RelationshipTypes:
    """Standard relationship types for entity connections."""

    # Medical/biomedical relationships
    TREATS = "treats"
    CAUSES = "causes"
    PREVENTS = "prevents"
    INTERACTS_WITH = "interacts_with"
    LOCATED_IN = "located_in"
    PART_OF = "part_of"
    ASSOCIATED_WITH = "associated_with"

    # General relationships
    MENTIONS = "mentions"
    REFERS_TO = "refers_to"
    WORKS_FOR = "works_for"
    BASED_IN = "based_in"
    HAPPENS_ON = "happens_on"

    @classmethod
    def all_types(cls) -> set:
        """Return all available relationship types."""
        return {
            cls.TREATS,
            cls.CAUSES,
            cls.PREVENTS,
            cls.INTERACTS_WITH,
            cls.LOCATED_IN,
            cls.PART_OF,
            cls.ASSOCIATED_WITH,
            cls.MENTIONS,
            cls.REFERS_TO,
            cls.WORKS_FOR,
            cls.BASED_IN,
            cls.HAPPENS_ON,
        }


# Example of how other models might be added later:
# @dataclass(frozen=True)
# class Chunk(Document):
#     """Represents a chunk of a larger document."""
#     parent_document_id: str
#     chunk_index: int
#     # Could have its own metadata or inherit/extend parent's

# @dataclass(frozen=True)
# class RetrievedDocument:
#     """Represents a document retrieved by the RAG pipeline, possibly with a score."""
#     document: Document
#     score: float = field(default=0.0)
#     # Any other retrieval-specific info
